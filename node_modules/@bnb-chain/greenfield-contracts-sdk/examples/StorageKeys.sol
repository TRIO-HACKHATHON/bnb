// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "../@openzeppelin/contracts/access/AccessControl.sol";

import "../BucketApp.sol";

contract SecretKeyStorage is BucketApp {
    BucketApp private bucketApp;


    mapping(address => mapping(string => address)) private secretKeys;
    mapping(address => address[]) private accessableAccounts;
    mapping(address => string[]) private allSecretKeys;
    mapping(address => address[]) private allSecretValues;

    mapping(uint256 => bool) private editPermission;
    mapping(uint256 => bool) private viewPermission;

    mapping(uint256 => mapping(string => bool)) private editPermissionBySecret;
    mapping(uint256 => mapping(string => bool)) private viewPermissionBySecret;

    constructor() {
        for (uint256 i = 1; i <= 10; i++) {
            editPermission[i] = true;
            viewPermission[i] = true;
        }

        for (uint256 i = 11; i <= 20; i++) {
            viewPermission[i] = true;
        }
    }

    modifier canEdit(uint256 id, string memory key) {
        require(editPermission[id] || editPermissionBySecret[id][key], "You don't have permission to edit.");
        _;
    }

    modifier canView(uint256 id, string memory key) {
        require(viewPermission[id] || viewPermissionBySecret[id][key], "You don't have permission to view.");
        _;
    }

    function storeSecretKey(string memory key, address value) public canEdit(1, key) {
        secretKeys[msg.sender][key] = value;
        allSecretKeys[msg.sender].push(key);
        allSecretValues[msg.sender].push(value);
        createMyBucket(
        address msg.sender, 
        string memory value,  
        address msg.sender, 
        address _spAddress, 
        uint256 _expireHeight, 
        bytes calldata _sig, 
        uint64 _chargedReadQuota
        );
    }

    function getSecretKey(string memory key) public view canView(1, key) returns (address) {
        return secretKeys[msg.sender][key];
    }

    function deleteSecretKey(string memory key) public canEdit(1, key) {
        delete secretKeys[msg.sender][key];
        deleteStringFromArray(allSecretKeys[msg.sender], key);
        deleteAddressFromArray(allSecretValues[msg.sender], msg.sender);
        deleteBucket(
        uint256 _tokenId, 
        address _refundAddress, 
        PackageQueue.FailureHandleStrategy _failureHandleStrategy, 
        bytes memory _callbackData, 
        uint256 _callbackGasLimit
        ) 
    }

    function setAccessibleAccounts(address account) public canEdit(1, "") {
        require(account != msg.sender, "You cannot add yourself to accessible accounts.");
        accessableAccounts[msg.sender].push(account);
        for (uint8 i = 0; i < allSecretKeys[msg.sender].length; i++) {
            secretKeys[account][allSecretKeys[msg.sender][i]] = allSecretValues[msg.sender][i];
            allSecretKeys[account].push(allSecretKeys[msg.sender][i]);
            allSecretValues[account].push(allSecretValues[msg.sender][i]);
        }
    }

    function getSecretKeys() public view returns (string[] memory) {
        return allSecretKeys[msg.sender];
    }

    function getAccessibleAccounts() public view returns (address[] memory) {
        return accessableAccounts[msg.sender];
    }

    function deleteStringFromArray(string[] storage array, string memory key) private {
        for (uint256 i = 0; i < array.length; i++) {
            if (keccak256(bytes(array[i])) == keccak256(bytes(key))) {
                if (i != array.length - 1) {
                    array[i] = array[array.length - 1];
                }
                array.pop();
                break;
            }
        }
    }

    function deleteAddressFromArray(address[] storage array, address value) private {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == value) {
                if (i != array.length - 1) {
                    array[i] = array[array.length - 1];
                }
                array.pop();
                break;
            }
        }
    }
    
    // Bucket bizim greenfield üzerindeki verimizdir.
    // Bucket oluşturma 
    function createMyBucket(
        address _creator, 
        string memory _name,  
        address _paymentAddress, 
        address _spAddress, 
        uint256 _expireHeight, 
        bytes calldata _sig, 
        uint64 _chargedReadQuota
    ) public {
        bucketApp.createBucket(
            _creator, 
            _name, 
            BucketApp.BucketVisibilityType.PRIVATE, 
            _paymentAddress, 
            _spAddress, 
            _expireHeight, 
            _sig, 
            _chargedReadQuota
        );
    }

    // Bucket silme fonksiyonu:
    function deleteBucket(
    uint256 _tokenId, 
    address _refundAddress, 
    PackageQueue.FailureHandleStrategy _failureHandleStrategy, 
    bytes memory _callbackData, 
    uint256 _callbackGasLimit
    ) 
        external 
        onlyRole(OPERATOR_ROLE) 
    {
        _deleteBucket(
            _tokenId, 
            _refundAddress, 
            _failureHandleStrategy, 
            _callbackData, 
            _callbackGasLimit
        );
    }


    //Bucket kaynak paketini yeniden deneme fonksiyonu:
    function retryBucketPackage() external onlyRole(OPERATOR_ROLE) {
        _retryBucketPackage();
    }

    // Bucket kaynak paketini atlama fonksiyonu:
    function skipBucketPackage() external onlyRole(OPERATOR_ROLE) {
        _skipBucketPackage();
    }

    // Bucket kaynak geri çağrısı için yönlendirici fonksiyon:
    function bucketGreenfieldCall(
        uint32 status, 
        uint8 operationType, 
        uint256 resourceId, 
        bytes calldata callbackData
    ) 
        external 
        onlyRole(OPERATOR_ROLE) 
    {
        _bucketGreenfieldCall(
            status, 
            operationType, 
            resourceId, 
            callbackData
        );
    }
}
